'''
created by edgard.ramos (ismytv@gmail.com)
generated by alice.bash.v.2203a
__date__
'''
from django.db import transaction
from base.libs.table import Table
from base import config as PARAMS
from base.models import Cuenta, Movimiento
from base.choices import TipoMovimientoChoices, TipoOperacionChoices
from base.business.bcuenta import BCuenta
 

class BMovimiento(Table):
    aMessage = []           # lista de mensajes

    def __init__(self):
        self.TO = Movimiento
        self.message_tablename = self.TO._meta.verbose_name
        self.aMessage = []

    def get_aTO_toArray(self):
        array = list()
        for oTO in self.aTO:
            array.append(self.get_oTO_toDict(oTO))
        return array
    
    def get_oTO_toDict(self, oTO:Movimiento):
        # acá se genera diccionario con los atributos a retornar
        return {
            'id':oTO.id,
            'id_movimiento':oTO.id_movimiento,
            'cuenta': oTO.cuenta.desc,
            'tipo_movimiento': oTO.tipo_movimiento,
            'tipo_movimiento_desc':TipoMovimientoChoices.get_desc(oTO.tipo_movimiento),
            'tipo_operacion_desc':TipoOperacionChoices.get_desc(oTO.tipo_operacion),
            'monto':oTO.monto,
            'fecha_movimiento':oTO.fecha_movimiento.strftime("%d/%m/%Y"),
            'concepto_gasto_desc':oTO.concepto_gasto.desc if oTO.concepto_gasto!=None else '',
            'obs':oTO.obs if oTO.obs != None else ''
        }

    ''' ----------------------
        Métodos personalizados
    '''
    def _set_oTO(self, oTO:Movimiento, data:dict(), mode, request):
        '''
            Personalizar oTO
        '''
        
        oTO.cuenta = data['cuenta']
        oTO.tipo_movimiento = data['tipo_movimiento']
        oTO.tipo_operacion = data['tipo_operacion']
        oTO.monto = data['monto']
        if 'id_movimiento' in data:
            oTO.id_movimiento = data['id_movimiento']
        if 'concepto_gasto' in data:
            oTO.concepto_gasto = data['concepto_gasto']
        if 'obs' in data:
            oTO.obs = data['obs']
        if 'fecha_movimiento' in data:
            oTO.fecha_movimiento = data['fecha_movimiento']

        if mode != 'new':
            oTO.user_edit_id = request.user.id
        else:
            oTO.user_created_id = request.user.id
            oTO.license_id = request.user.license_id
        return oTO
    
    def validate(self, data:list()):
        self.aMessage = []
        return True

    @transaction.atomic
    def save(self, request, mode, id, data:list()):
        ok = False
        if mode == 'new' :
            oTO = self.TO()
            oTO = self._set_oTO(oTO, data, mode, request)
            ok = self.insert(oTO)

            # udpdate saldo cuenta
            oBCuenta = BCuenta()
            oTOCuenta = oBCuenta.get(oTO.cuenta.id)
            if oTO.tipo_movimiento == TipoMovimientoChoices.egreso:
                oTOCuenta.saldo -= oTO.monto
            else:
                oTOCuenta.saldo += oTO.monto
            oBCuenta.update(oTOCuenta)
        
        else: # edit
            oTO = self.get(id)
            if oTO == None:
                self.message = f'No se encontro registro con id={id}'
                self.error_code = PARAMS.ErrorCode.not_found
            else:
                monto_old = oTO.monto
                oTO = self._set_oTO(oTO, data, mode, request,)
                ok = self.update(oTO)

                # update saldo cuenta
                oBCuenta = BCuenta()
                oTOCuenta = oBCuenta.get(oTO.cuenta.id)
                if oTO.tipo_movimiento == TipoMovimientoChoices.egreso:
                    if oTO.monto > monto_old:
                        oTOCuenta.saldo -= (oTO.monto - monto_old)
                    else:
                        oTOCuenta.saldo += (monto_old - oTO.monto)
                else:
                    if oTO.monto > monto_old:
                        oTOCuenta.saldo += (oTO.monto - monto_old)
                    else:
                        oTOCuenta.saldo -= (monto_old - oTO.monto)
                oBCuenta.update(oTOCuenta)

        return ok
    
    def get_all(self, license_id:int=None):
        if license_id == None:
            self.aTO = self.TO.objects.all().order_by('-fecha_movimiento')
        else:
            self.aTO = self.TO.objects.all().filter(license_id=license_id).order_by('-fecha_movimiento')
        return self.aTO
    

    def set_data_pagosvarios(self, cleaned_data:dict()):
        return {
            'cuenta' : cleaned_data['cuenta'],
            'monto' : cleaned_data['monto'],
            'obs' : cleaned_data['obs'],
            'concepto_gasto' : cleaned_data['concepto_gasto'],
            'tipo_movimiento' : TipoMovimientoChoices.egreso,
            'tipo_operacion' : TipoOperacionChoices.pagos_varios,
            'obs': cleaned_data['obs'],
            'fecha_movimiento': cleaned_data['fecha_movimiento']
        } 

    @transaction.atomic
    def save_pagosvarios(self, request, mode, id, data:list()):
        data = self.set_data_pagosvarios(data)
        ok = False
        if mode == 'new' :
            oTO = self.TO()
            oTO = self._set_oTO(oTO, data, mode, request)
            ok = self.insert(oTO)

            # udpdate saldo cuenta
            oBCuenta = BCuenta()
            oTOCuenta = oBCuenta.get(oTO.cuenta.id)
            oTOCuenta.saldo -= oTO.monto
            oBCuenta.update(oTOCuenta)
        
        else: # edit
            oTO = self.get(id)
            if oTO == None:
                self.message = f'No se encontro registro con id={id}'
                self.error_code = PARAMS.ErrorCode.not_found
            else:
                oTO = self._set_oTO(oTO, data, mode, request,)
                ok = self.update(oTO)
        return ok

    def set_data_transferenciaspropias(self, cleaned_data:dict(), tipo_movimiento, oTOCuenta):
        return {
            'cuenta' : oTOCuenta,
            'monto' : cleaned_data['monto'],
            'tipo_movimiento' : tipo_movimiento,
            'tipo_operacion' : TipoOperacionChoices.transferencia_propias,
            'obs': cleaned_data['obs'],
            'fecha_movimiento': cleaned_data['fecha_movimiento']
        } 


    @transaction.atomic
    def save_transferenciaspropias(self, request, mode, id, data:list()):
        ok = False
        print(data)
        if mode == 'new' :
            cuenta_origen = data['cuenta_origen']
            cuenta_destino = data['cuenta_destino']

            # 1. Save movimiento egreso
            oBCuenta = BCuenta()
            oTOCuenta:Cuenta = oBCuenta.get(cuenta_origen)
            data = self.set_data_transferenciaspropias(data, TipoMovimientoChoices.egreso, oTOCuenta)
            oTO = self.TO()
            oTO = self._set_oTO(oTO, data, mode, request)
            ok = self.insert(oTO)
            # 1.1. Update saldo cuenta
            oTOCuenta.saldo -= oTO.monto
            oBCuenta.update(oTOCuenta)

            # 2. Save movimiento ingreso
            oBCuenta = BCuenta()
            oTOCuenta:Cuenta = oBCuenta.get(cuenta_destino)
            data = self.set_data_transferenciaspropias(data, TipoMovimientoChoices.ingreso, oTOCuenta)
            oTO = self.TO()
            oTO = self._set_oTO(oTO, data, mode, request)
            ok = self.insert(oTO)
            # 1.1. Update saldo cuenta
            oTOCuenta.saldo += oTO.monto
            oBCuenta.update(oTOCuenta)

        
        else: # edit
            oTO = self.get(id)
            if oTO == None:
                self.message = f'No se encontro registro con id={id}'
                self.error_code = PARAMS.ErrorCode.not_found
            else:
                oTO = self._set_oTO(oTO, data, mode, request,)
                ok = self.update(oTO)
        return ok