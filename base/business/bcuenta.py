'''
created by edgard.ramos (ismytv@gmail.com)
generated by alice.bash.v.2203a
__date__
'''
from functools import reduce
from base.business.bcompra import BCompra
from base.libs.table import Table
from base import config as PARAMS
from base.models import Cuenta
from base.choices import TipoCuentaChoices, MonedaChoices, DestinoCuentaChoices


class BCuenta(Table):
    aMessage = []           # lista de mensajes

    def __init__(self):
        self.TO = Cuenta
        self.message_tablename = self.TO._meta.verbose_name
        self.aMessage = []

    def get_aTO_toArray(self):
        array = list()
        for oTO in self.aTO:
            array.append(self.get_oTO_toDict(oTO))
        return array
    
    def get_oTO_toDict(self, oTO:Cuenta):
        # acá se genera diccionario con los atributos a retornar
        return {
            'id':oTO.id,
            'desc':oTO.desc,
            'tipo_cuenta_desc': TipoCuentaChoices.get_desc(oTO.tipo_cuenta),
            'banco_desc':oTO.banco.desc,
            'saldo':oTO.saldo,
            'saldo_apertura':oTO.saldo_apertura
        }

    ''' ----------------------
        Métodos personalizados
    '''
    def _set_oTO(self, oTO:Cuenta, data:list(), mode, request):
        '''
            Personalizar oTO
        '''
        if mode != 'new':
            saldo_apertura_old = oTO.saldo_apertura         

        oTO.desc = data['desc']
        oTO.tipo_cuenta = data['tipo_cuenta']
        oTO.banco = data['banco']
        oTO.moneda = data['moneda']
        oTO.destino_cuenta = data['destino_cuenta']
        oTO.numero_cuenta = data['numero_cuenta']
        oTO.saldo_apertura = data['saldo_apertura']

        if mode != 'new':
            # actualizar saldo cuenta (por correccion saldo apertura)
            print(oTO.saldo_apertura, saldo_apertura_old)
            if oTO.saldo_apertura > saldo_apertura_old:
                oTO.saldo += (oTO.saldo_apertura - saldo_apertura_old)
            else:
                oTO.saldo -= (saldo_apertura_old - oTO.saldo_apertura)
            oTO.user_edit_id = request.user.id
        else:
            oTO.saldo = oTO.saldo_apertura
            oTO.user_created_id = request.user.id
            oTO.license_id = request.user.license_id
        return oTO
    
    def validate(self, data:list()):
        self.aMessage = []
        return True

    def save(self, request, mode, id, data:list()):
        ok = False
        if mode == 'new' :
            oTO = self.TO()
            oTO = self._set_oTO(oTO, data, mode, request)
            ok = self.insert(oTO)
        
        else: # edit
            oTO = self.get(id)
            if oTO == None:
                self.message = f'No se encontro registro con id={id}'
                self.error_code = PARAMS.ErrorCode.not_found
            else:
                oTO = self._set_oTO(oTO, data, mode, request)
                ok = self.update(oTO)
            
        return ok
    
    def get_all(self, license_id:int=None):
        if license_id == None:
            self.aTO = self.TO.objects.all().order_by('desc')
        else:
            self.aTO = self.TO.objects.all().filter(license_id=license_id).order_by('desc')
        return self.aTO
    
    def get_cuentas_by_moneda_choices(self, is_moneda_local):
        # requiere self.aTO tenga los  datos
        if is_moneda_local:
            list_filter = list(filter(lambda x: x.moneda==MonedaChoices.moneda_local, self.aTO))
        else:
            list_filter = list(filter(lambda x: x.moneda!=MonedaChoices.moneda_local, self.aTO))
        return list(map(lambda item: (item.id, item.desc), list_filter))
    
    def get_cuentas_by_destino_choices(self, is_efectivo, is_moneda_local=True):
        # requiere self.aTO tenga los  datos
        if is_efectivo:
            list_filter = list(filter(lambda x: x.destino_cuenta==DestinoCuentaChoices.efectivo, self.aTO))
        else:
            list_filter = list(filter(lambda x: x.destino_cuenta!=DestinoCuentaChoices.efectivo, self.aTO))
        
        if is_moneda_local:
            list_filter = list(filter(lambda x: x.moneda==MonedaChoices.moneda_local, list_filter))
        else:
            list_filter = list(filter(lambda x: x.moneda!=MonedaChoices.moneda_local, list_filter))

        return list(map(lambda item: (item.id, item.desc), list_filter))
    
    def get_desc(self, id):
        oTO = self.get(id)
        return oTO.desc if oTO != None else ''
    
    def get_all_choices(self, license_id:None):
        self.get_all(license_id)
        return list(map(lambda item: (item.id, item.desc), self.aTO))
    
    def get_resumen(self):
        '''
            Devuelve un dict con los totales en soles, dolares y ahorro
            Requiere self.aTO tenga los datos de Cuenta
        '''
        total_soles = reduce(lambda x,y:x+y.saldo 
                            if y.moneda==MonedaChoices.soles else x, 
                            self.aTO, 0)
        total_dolares = reduce(lambda x,y:x+y.saldo 
                            if y.moneda==MonedaChoices.dolares else x, 
                            self.aTO, 0)
        total_ahorro_soles = reduce(lambda x,y:x+y.saldo 
                            if y.moneda==MonedaChoices.soles 
                            and y.tipo_cuenta==TipoCuentaChoices.ahorro  
                            else x, 
                            self.aTO, 0)

        return {
            'total_soles' : total_soles,
            'total_dolares' : total_dolares,
            'total_ahorro_soles' : total_ahorro_soles,
            'total_soles_disponible': total_soles - total_ahorro_soles
        }
        